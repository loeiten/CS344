#include <cuda_runtime.h>  // for cudaDeviceSynchronize, cuda...
#include <driver_types.h>  // for cudaDeviceProp, cudaMemcpyD...
#include <stdio.h>         // for printf, size_t
#include <stdlib.h>        // for atof, exit
#include <vector_types.h>  // for uchar4

#include <filesystem>  // for absolute, path, create_dire...
#include <iostream>    // for operator<<, basic_ostream
#include <map>         // for map, operator==, map<>::ite...
#include <string>      // for string, allocator, operator+

#include "../include/compare.hpp"         // for compareImages
#include "../include/image.hpp"           // for Image
#include "../include/reference_calc.hpp"  // for referenceCalculation
#include "../include/timer.hpp"           // for GpuTimer
#include "../include/utils.hpp"           // for check, checkCudaErrors

// Declare function found in student_func.cu
// We cannot include this as an header as it contains device code
void your_rgba_to_greyscale(uchar4 *const d_rgbaImage,
                            unsigned char *const d_greyImage, size_t num_rows,
                            size_t num_cols);

int main(int argc, char **argv) {
  uchar4 *h_rgbaImage, *d_rgbaImage;
  unsigned char *h_greyImage, *d_greyImage;

  std::filesystem::path input_path;
  std::filesystem::path output_path;
  std::filesystem::path reference_path;
  std::string base_name = "cinque_terre";
  std::string extension = "gold";
  std::string output_dir_name = "output";
  std::string file_name;
  double per_pixel_error = 0.0;
  double global_error = 0.0;
  bool useEpsCheck = false;
  switch (argc) {
    case 1:
      file_name = "./data/" + base_name + "." + extension;
      input_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 2:
      input_path = std::filesystem::absolute(argv[1]);
      base_name = input_path.stem().string();
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 3:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      base_name = input_path.stem().string();
      file_name = base_name + "_cpu.png";
      reference_path = output_path.parent_path() / file_name;
      break;
    case 4:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      break;
    case 6:
      useEpsCheck = true;
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      per_pixel_error = atof(argv[4]);
      global_error = atof(argv[5]);
      break;
    default:
      std::cerr
          << "Usage: ./problem_set_1 [input_path] [output_path] "
             "[reference_path] [per_pixel_error] [global_error]\n"
             "The output_path and reference_path will be generated by the "
             "code.\n"
             "The per_pixel_error and global_error are epsilon tolerances."
          << std::endl;
      exit(1);
  }
  // Create the directories
  if (!std::filesystem::exists((output_path.parent_path()))) {
    std::filesystem::create_directories(output_path.parent_path());
  }
  if (!std::filesystem::exists((reference_path.parent_path()))) {
    std::filesystem::create_directories(reference_path.parent_path());
  }

  Image image;

  // load the image and give us our input and output pointers
  image.preProcess(&h_rgbaImage, &h_greyImage, &d_rgbaImage, &d_greyImage,
                   input_path.string());

  GpuTimer timer;
  timer.Start();
  // call the students' code
  your_rgba_to_greyscale(d_rgbaImage, d_greyImage, image.num_rows(),
                         image.num_cols());
  timer.Stop();
  cudaDeviceSynchronize();
  checkCudaErrors(cudaGetLastError());

  float elapsed_ms = timer.Elapsed();
  int err = printf("Your code ran in: %f msecs.\n", elapsed_ms);

  if (err < 0) {
    // Couldn't print! Probably the student closed stdout - bad news
    std::cerr << "Couldn't print timing information! STDOUT Closed!"
              << std::endl;
    exit(1);
  }

  size_t numPixels = image.num_rows() * image.num_cols();

  checkCudaErrors(cudaMemcpy(h_greyImage, d_greyImage,
                             sizeof(unsigned char) * numPixels,
                             cudaMemcpyDeviceToHost));

  // check results and output the grey image
  image.postProcess(output_path.string(), h_greyImage);

  referenceCalculation(h_rgbaImage, h_greyImage, image.num_rows(),
                       image.num_cols());

  image.postProcess(reference_path.string(), h_greyImage);

  compareImages(reference_path, output_path, useEpsCheck, per_pixel_error,
                global_error);

  return 0;
}
