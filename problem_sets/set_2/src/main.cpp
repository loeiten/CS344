#include <cuda_runtime.h>  // for cudaFree, cudaDeviceSynchro...
#include <stdio.h>         // for size_t, printf
#include <stdlib.h>        // for atof, exit

#include <filesystem>  // for absolute, path, create_dire...
#include <iostream>    // for operator<<, endl, basic_ost...
#include <string>      // for allocator, operator+, string

#include "../include/compare.hpp"         // for compareImages
#include "../include/image.hpp"           // for Image
#include "../include/reference_calc.hpp"  // for referenceCalculation
#include "../include/timer.hpp"           // for GpuTimer
#include "../include/utils.hpp"           // for check, checkCudaErrors
#include "driver_types.h"                 // for cudaMemcpyDeviceToHost
#include "vector_types.h"                 // for uchar4

// Declare function found in student_func.cu
// We cannot include this as an header as it contains device code
void your_gaussian_blur(const uchar4 *const h_inputImageRGBA,
                        uchar4 *const d_inputImageRGBA,
                        uchar4 *const d_outputImageRGBA, const size_t numRows,
                        const size_t numCols, unsigned char *d_redBlurred,
                        unsigned char *d_greenBlurred,
                        unsigned char *d_blueBlurred, const int filterWidth);

void allocateMemoryAndCopyToGPU(const size_t numRowsImage,
                                const size_t numColsImage,
                                const float *const h_filter,
                                const size_t filterWidth);

int main(int argc, char **argv) {
  uchar4 *h_inputImageRGBA, *d_inputImageRGBA;
  uchar4 *h_outputImageRGBA, *d_outputImageRGBA;
  unsigned char *d_redBlurred, *d_greenBlurred, *d_blueBlurred;

  float *h_filter;
  int filterWidth;

  std::filesystem::path input_path;
  std::filesystem::path output_path;
  std::filesystem::path reference_path;
  std::string base_name = "cinque_terre";
  std::string extension = "gold";
  std::string output_dir_name = "output";
  std::string file_name;
  double per_pixel_error = 0.0;
  double global_error = 0.0;
  bool useEpsCheck = false;
  switch (argc) {
    case 1:
      file_name = "./data/" + base_name + "." + extension;
      input_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 2:
      input_path = std::filesystem::absolute(argv[1]);
      base_name = input_path.stem().string();
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 3:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      base_name = input_path.stem().string();
      file_name = base_name + "_cpu.png";
      reference_path = output_path.parent_path().concat(file_name);
      break;
    case 4:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      break;
    case 6:
      useEpsCheck = true;
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      per_pixel_error = atof(argv[4]);
      global_error = atof(argv[5]);
      break;
    default:
      std::cerr
          << "Usage: ./problem_set_2 [input_path] [output_path] "
             "[reference_path] [per_pixel_error] [global_error]\n"
             "The output_path and reference_path will be generated by the "
             "code.\n"
             "The per_pixel_error and global_error are epsilon tolerances."
          << std::endl;
      exit(1);
  }
  // Create the directories
  if (!std::filesystem::exists((output_path.parent_path()))) {
    std::filesystem::create_directories(output_path.parent_path());
  }
  if (!std::filesystem::exists((reference_path.parent_path()))) {
    std::filesystem::create_directories(reference_path.parent_path());
  }

  Image image;

  // load the image and give us our input and output pointers
  image.preProcess(&h_inputImageRGBA, &h_outputImageRGBA, &d_inputImageRGBA,
                   &d_outputImageRGBA, &d_redBlurred, &d_greenBlurred,
                   &d_blueBlurred, &h_filter, &filterWidth,
                   input_path.string());

  allocateMemoryAndCopyToGPU(image.numRows(), image.numCols(), h_filter,
                             filterWidth);
  GpuTimer timer;
  timer.Start();
  // call the students' code
  your_gaussian_blur(h_inputImageRGBA, d_inputImageRGBA, d_outputImageRGBA,
                     image.numRows(), image.numCols(), d_redBlurred,
                     d_greenBlurred, d_blueBlurred, filterWidth);
  timer.Stop();
  cudaDeviceSynchronize();
  checkCudaErrors(cudaGetLastError());
  int err = printf("Your code ran in: %f msecs.\n", timer.Elapsed());

  if (err < 0) {
    // Couldn't print! Probably the student closed stdout - bad news
    std::cerr << "Couldn't print timing information! STDOUT Closed!"
              << std::endl;
    exit(1);
  }

  // check results and output the blurred image

  size_t numPixels = image.numRows() * image.numCols();
  // copy the output back to the host
  checkCudaErrors(cudaMemcpy(h_outputImageRGBA, image.d_outputImageRGBA__,
                             sizeof(uchar4) * numPixels,
                             cudaMemcpyDeviceToHost));

  image.postProcess(output_path.string(), h_outputImageRGBA);

  referenceCalculation(h_inputImageRGBA, h_outputImageRGBA, image.numRows(),
                       image.numCols(), h_filter, filterWidth);

  image.postProcess(reference_path.string(), h_outputImageRGBA);

  //  Cheater easy way with OpenCV
  // generateReferenceImage(input_file, reference_file, filterWidth);

  compareImages(reference_path.filename(), output_path.filename(), useEpsCheck,
                per_pixel_error, global_error);

  checkCudaErrors(cudaFree(d_redBlurred));
  checkCudaErrors(cudaFree(d_greenBlurred));
  checkCudaErrors(cudaFree(d_blueBlurred));

  return 0;
}
