#include <cuda_runtime.h>      // for cudaDeviceSynchronize
#include <cuda_runtime_api.h>  // for cudaMemcpy, cudaGetLastError, cudaGetDe...
#include <driver_types.h>      // for cudaMemcpyDeviceToHost, cudaDeviceProp
#include <stdio.h>             // for printf, size_t
#include <stdlib.h>            // for atof, exit
#include <vector_types.h>      // for uchar4

#include <filesystem>  // for path, absolute
#include <iostream>    // for operator<<, endl, basic_o...
#include <map>         // for map
#include <string>      // for string

#include "../include/compare.hpp"         // for compareImages
#include "../include/image.hpp"           // for num_cols, num_rows, postPro...
#include "../include/reference_calc.hpp"  // for referenceCalculation
#include "../include/timer.hpp"           // for GpuTimer
#include "../include/utils.hpp"           // for check, checkCudaErrors

// Declare function found in student_func.cu
// We cannot include this as an header as it contains device code
void your_rgba_to_greyscale(uchar4 *const d_rgbaImage,
                            unsigned char *const d_greyImage, size_t num_rows,
                            size_t num_cols);

int main(int argc, char **argv) {
  uchar4 *h_rgbaImage, *d_rgbaImage;
  unsigned char *h_greyImage, *d_greyImage;

  std::filesystem::path input_path;
  std::filesystem::path output_path;
  std::filesystem::path reference_path;
  std::string base_name = "cinque_terre";
  std::string extension = "gold";
  std::string output_dir_name = "output";
  std::string file_name;
  double per_pixel_error = 0.0;
  double global_error = 0.0;
  bool useEpsCheck = false;
  switch (argc) {
    case 1:
      file_name = "./data/" + base_name + "." + extension;
      input_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 2:
      input_path = std::filesystem::absolute(argv[1]);
      base_name = input_path.stem().string();
      file_name = "./" + output_dir_name + "/" + base_name + "_gpu.png";
      output_path = std::filesystem::absolute(file_name);
      file_name = "./" + output_dir_name + "/" + base_name + "_cpu.png";
      reference_path = std::filesystem::absolute(file_name);
      break;
    case 3:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      base_name = input_path.stem().string();
      file_name = base_name + "_cpu.png";
      reference_path = output_path.parent_path() / file_name;
      break;
    case 4:
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      break;
    case 6:
      useEpsCheck = true;
      input_path = std::filesystem::absolute(argv[1]);
      output_path = std::filesystem::absolute(argv[2]);
      reference_path = std::filesystem::absolute(argv[3]);
      per_pixel_error = atof(argv[4]);
      global_error = atof(argv[5]);
      break;
    default:
      std::cerr
          << "Usage: ./problem_set_1 [input_path] [output_path] "
             "[reference_path] [per_pixel_error] [global_error]\n"
             "The output_path and reference_path will be generated by the "
             "code.\n"
             "The per_pixel_error and global_error are epsilon tolerances."
          << std::endl;
      exit(1);
  }
  // Create the directories
  if (!std::filesystem::exists((output_path.parent_path()))) {
    std::filesystem::create_directories(output_path.parent_path());
  }
  if (!std::filesystem::exists((reference_path.parent_path()))) {
    std::filesystem::create_directories(reference_path.parent_path());
  }

  Image image;

  // load the image and give us our input and output pointers
  image.preProcess(&h_rgbaImage, &h_greyImage, &d_rgbaImage, &d_greyImage,
                   input_path.string());

  GpuTimer timer;
  timer.Start();
  // call the students' code
  your_rgba_to_greyscale(d_rgbaImage, d_greyImage, image.num_rows(),
                         image.num_cols());
  timer.Stop();
  cudaDeviceSynchronize();
  checkCudaErrors(cudaGetLastError());

  float elapsed_ms = timer.Elapsed();
  int err = printf("Your code ran in: %f msecs.\n", elapsed_ms);

  if (err < 0) {
    // Couldn't print! Probably the student closed stdout - bad news
    std::cerr << "Couldn't print timing information! STDOUT Closed!"
              << std::endl;
    exit(1);
  }

  size_t numPixels = image.num_rows() * image.num_cols();

  // Calculate performance compared to ideal
  // We can see how well we are performing by checking achieved
  // throughput/bandwidth
  //
  // WARNING: The cinque_terre image is likely too small to measure the
  //          performance as we're also measuring the kernel launch overheads
  //          etc.
  //          To get a more realistic number either pick a larger image, or make
  //          the launch so that it loops over more data
  //
  // The achieved throughput (measured before and after the kernel)
  // = 2*Bytes in image/time it took
  // We multiply with 2 as there will be at least be one read and one write
  // operation
  //
  // NOTE: This assumes that the whole image is processed in one kernel on one
  //       GPU
  int bytes_processed = 2 * sizeof(uchar4) * numPixels;
  // Memory bandwidth for the device
  // From
  // https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf
  std::map<std::string, float> device_bw{{"NVIDIA A100-PG509-200", 1.555e9}};
  int devCount;
  bool calculate_performance = true;
  cudaGetDeviceCount(&devCount);
  std::string prev_name = "";
  std::string name;
  for (int i = 0; i < devCount; ++i) {
    cudaDeviceProp props;
    cudaGetDeviceProperties(&props, i);
    name = props.name;
    if (prev_name != "") {
      if (prev_name != name) {
        std::cerr << "Warning: There is a mix of devices, could not calculate "
                     "the performance number"
                  << std::endl;
        calculate_performance = false;
        break;
      }
    }
    prev_name = name;
  }
  if (calculate_performance) {
    if (device_bw.find(name) == device_bw.end()) {
      std::cerr << "Warning: Do not know the memory bandwidth of " << name
                << ", please look it up, and add it to device_bw" << std::endl;
    } else {
      float performance =
          100 * (bytes_processed / (elapsed_ms / 1.0e3)) / (device_bw[name]);
      std::cout << "Processed " << bytes_processed << " bytes in " << elapsed_ms
                << " ms" << std::endl;
      std::cout << "As the max bandwidth of the system is" << device_bw[name]
                << "bytes/sec for " << name << ", this is " << performance
                << "% of theoretical max" << std::endl;
    }
  }

  checkCudaErrors(cudaMemcpy(h_greyImage, d_greyImage,
                             sizeof(unsigned char) * numPixels,
                             cudaMemcpyDeviceToHost));

  // check results and output the grey image
  image.postProcess(output_path.string(), h_greyImage);

  referenceCalculation(h_rgbaImage, h_greyImage, image.num_rows(),
                       image.num_cols());

  image.postProcess(reference_path.string(), h_greyImage);

  // generateReferenceImage(input_path, reference_path);
  compareImages(reference_path, output_path, useEpsCheck, per_pixel_error,
                global_error);

  return 0;
}
